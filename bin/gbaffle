#!/usr/bin/env ruby

require 'rubygems'
require 'gtk2'
require 'rexml/document'
require 'baffle'

include REXML

if str = Gtk.check_version(2, 6, 0)
  puts "This app requires GTK+ 2.6.0 or later"
  puts str
  exit
end

win = Gtk::Window.new("BAFFLE Gtk-ruby Frontend")
win.set_default_size(800, 100)
win.signal_connect("delete_event"){
  Gtk.main_quit
}

#
#  MAC_entry_combo   add  remove  add_from_file
#
#
#
#
#

topvbox = Gtk::VBox.new
inhbox  = Gtk::HBox.new

topvbox.add(inhbox)

# "Globals" tied with the combo box
mac_cnt = 0
macs = {}

macs_combo   = Gtk::ComboBoxEntry.new
lb_count     = Gtk::Label.new("[ScanList: #{mac_cnt} APs]")
bt_add_mac   = Gtk::Button.new("Add MAC")
bt_del_mac   = Gtk::Button.new("Del MAC")
bt_from_file = Gtk::Button.new("From Kismet")

#
#  We need mac_cnt and macs_combo in scope for the following two functions
#    They must keep the MAC list synchronized with the contents of macs_combo
#    Note that bt_del_mac operates on the "internals" of both!
#
#  FIX: prevent duplicates! Canonicalize MAC addresses and check if already added
#
update_lb_count = proc {  
  lb_count.set_text("[ScanList: #{mac_cnt} APs]")
}

add_mac_to_scan_list = proc { |bssid, essid, prepend|
  if prepend then
    macs_combo.prepend_text( bssid )
  else
    macs_combo.append_text("#{bssid} #{essid}")
  end

  macs[bssid.downcase] = essid
  mac_cnt += 1
  update_lb_count.call
}


inhbox.add(macs_combo)
inhbox.add(lb_count)
inhbox.add(bt_add_mac)
inhbox.add(bt_del_mac)
inhbox.add(bt_from_file)

bar   = Gtk::ProgressBar.new

topvbox.add(bar)

macs_combo.active = 1

bt_scan_all = Gtk::Button.new("  Scan all   ")
bt_scan_sel = Gtk::Button.new("Scan selected")

bt_scan_box = Gtk::HBox.new
bt_scan_box.add(bt_scan_all).add(bt_scan_sel)

topvbox.add(bt_scan_box)

#scrolled_win = Gtk::ScrolledWindow.new
#scrolled_win.set_policy(Gtk::POLICY_AUTOMATIC,Gtk::POLICY_AUTOMATIC)
#topvbox.add(scrolled_win)

no_results_yet = true

#scrolled_win.height_request= 240
#scrolled_win.add_with_viewport(svbox)

nbook = Gtk::Notebook.new
nbook.scrollable= true

topvbox.add(nbook)

#
#  Add results 
#
add_ap_result = proc { |res, append_results|  
  # hash with RES contains text string, IMG the svg image, LBL the tab label

  no_results_yet = false

  # Create a new notebook page and append it
  svbox = Gtk::VBox.new
  lb_res  = Gtk::Label.new("No results yet");
  sep     = Gtk::HSeparator.new
  img_res = Gtk::Image.new("pint.png")

  lb_res.set_text( res['RES'] )
  img_res.file= res['IMG']

  lb_tab  = Gtk::Label.new(res['LBL'])

  svbox.add(lb_res).add(sep).add(img_res)
  nbook.append_page(svbox, lb_tab)

  win.show_all
}

#
# Add MAC button click
#
bt_add_mac.signal_connect("clicked") do
  if macs_combo.active_text.length > 0 then
    # FIX: check that this is a valid BSSID
    add_mac_to_scan_list.call( macs_combo.active_text, '', true ) 
  end
end

#
# Del MAC button click
#
bt_del_mac.signal_connect("clicked") do
  if count_rows(macs_combo) > 0 then
    del_idx = 0 
    if macs_combo.active >= 0  then
      del_idx = macs_combo.active
    end
    
    macs_combo.remove_text( del_idx ) 
    mac_cnt -= 1
    update_lb_count.call
    
    # set edit box to the start of the list
    macs_combo.active=(0)
    # macs_combo.child.set_text(mac)

    # DBG: print # of actual items after deletion
    # p count_rows(macs_combo)
  else
    # no items remain, clear edit box
    macs_combo.child.set_text("")
  end
end
  
def count_rows (combo) 
  count = 0
  combo.model.each {
    count += 1
  }
  return count
end



#label = Gtk::Label.new
#butt  = Gtk::Button.new("Stop")
#img   = Gtk::Image.new("watch.jpg")

#box.add(img).add(label).add(bar).add(butt)
#label.set_text("Progress bar:")

win.add(topvbox).show_all

#
#   Workhorse method: scans the AP
#
scan_ap = proc { |mac, essid|
  bar.text= "Probing AP #{mac} #{essid}"
  bar.pulse_step=(0.02)
  
  thr_stop = false
  #bar_thr = Thread.new do 
  #  until thr_stop do
  #    bar.pulse()
  #    sleep 0.05
  #  end
  #end
  
  args ['--interface', 'eth1', '--essid', essid, '--fpdiagram', "/tmp/#{mac}_", mac] 
  hypotheses = Baffle.run(args)
  thr_stop = true
  bar.fraction= 0
  
  bar.text= "Done with AP #{mac} #{essid}"
  
  hypotheses.each do |probe, hypothesis|
    results = {}
    results['LBL'] = "#{mac} #{essid} #{probe}"
    results['RES'] = hypothesis
    results['IMG'] = File.expand_path("/tmp/#{mac}_#{probe}.svg")

    add_ap_result.call(results, false)
  end
}




#
#  Start button click
#
#  Initiate the appropriate external command, and run the progress bar while waiting
#   for it to finish.
#
bt_scan_all.signal_connect("clicked"){
  macs.each { |key, val|
    scan_ap.call( key, val )
  }
}

bt_scan_sel.signal_connect("clicked"){
  #
  #  FIX: This passes anything currently in the edit box of the combo to scan_ap,
  #       even though it hasn't been "added" to the list.
  #
  sel_text = macs_combo.active_text
  if sel_text && sel_text.length > 0 then
    (mac, essid) = macs_combo.active_text.split(' ', 2)
    scan_ap.call( mac, essid )
  end
}

#   Dummy function to just run the progress bar back and forth
#  
#bt_scan_all.signal_connect("clicked"){
#  if thr_stop then
#    bt_scan.set_label("Stop")
#    thr_stop = false
#    thr.run
#  else
#    thr_stop = true
#    bt_scan_all.set_label("Resume")
#  end
#}

def is_valid_mac (str)
  if str =~ /^(?:[0-9a-fA-F]{2}:?\s*){5}:?\s*[0-9a-fA-F]{2}$/ then
    return true
  else
    p "#{str} is not understood as a MAC address"
    return false
  end
end
# ================= file chooser ====================================

add_macs_from_xml = proc { |filename|
  file = File.new(filename)
  doc  = Document.new(file)
  root = doc.root
  root.each_element("//wireless-network[@type='infrastructure']") { |elt|
    bssid = elt.elements['BSSID'].text

    # some networks have no SSID element
    essid = '<no ssid>'
    if elt.elements['SSID'] then
      essid = elt.elements['SSID'].text
    end

    add_mac_to_scan_list.call( bssid, essid, false )
  }
  macs_combo.active= 0
}

bt_from_file.signal_connect("clicked"){
  dialog =  Gtk::FileChooserDialog.new("Choose a Kismet CSV file", win,
                                       Gtk::FileChooser::ACTION_OPEN,
                                       nil, # "gnome-vfs",
                                       [Gtk::Stock::OPEN, Gtk::Dialog::RESPONSE_ACCEPT],
                                       [Gtk::Stock::CANCEL, Gtk::Dialog::RESPONSE_CANCEL]
                                       )

  if dialog.run == Gtk::Dialog::RESPONSE_ACCEPT
    puts "Parsing file: #{dialog.filename}"
    
    if dialog.filename =~ /\.csv$/i then
      # parse and set the macs in combox box
      File.open(dialog.filename).each { |line|
        (num, type, essid, bssid) = line.split(';')
        if is_valid_mac(bssid) and type == 'infrastructure' then
          add_mac_to_scan_list.call( bssid, essid, false )
        end
      }
      macs_combo.active= 0
    elsif dialog.filename =~ /\.xml$/i then
      add_macs_from_xml.call(dialog.filename)
      # p "No support for Kismet XML files yet"
    else
      p "I understand only Kismet CSV and XML (not yet) file formats"  
    end
  else
    puts "cancelled"
  end
  dialog.destroy
}
# ==========================================================================

Gtk.main
